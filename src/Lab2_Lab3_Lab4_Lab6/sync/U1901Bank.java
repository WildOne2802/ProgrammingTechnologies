package Lab2_Lab3_Lab4_Lab6.sync;

public class U1901Bank {
    private volatile int intTo;
    private volatile int intFrom = 220;

    public void calc(int intTransaction, long lngTimeout) {
        synchronized (U1901Bank.class) {
            System.out.println("[1] [ Before ]\tThread: " + Thread.currentThread().getName() + "\tintFrom: " + intFrom + "\tintTo: " + intTo);
            intFrom -= intTransaction;
            try {
                Thread.sleep(lngTimeout);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            intTo += intTransaction;

            System.out.println("[1] [ After ]\tThread: " + Thread.currentThread().getName() + "\tintFrom: " + intFrom + "\tintTo: " + intTo);
        }
    }

    public void calc2(int intTransaction, long lngTimeout) {
        synchronized (U1901Bank.class) {
            System.out.println("[2] [ Before ]\tThread: " + Thread.currentThread().getName() + "\tintFrom: " + intFrom + "\tintTo: " + intTo);
            intFrom -= intTransaction;
            try {
                Thread.sleep(lngTimeout);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            intTo += intTransaction;

            System.out.println("[2] [ After ]\tThread: " + Thread.currentThread().getName() + "\tintFrom: " + intFrom + "\tintTo: " + intTo);
        }
    }

}

//TODO:
// synchronized
// .
// [Монитор]
// .
// Монитор представляет своего рода инструмент для управления доступа к объекту.
// Когда выполнение кода доходит до оператора synchronized, монитор объекта res блокируется,
// и на время его блокировки монопольный доступ к блоку кода имеет только один поток, который и произвел блокировку.
// .
// [Вешая на метод synchronized]
// .
// Тут уже нет нужды явно указывать какой-то объект, по которому осуществляется синхронизация.
// Раз словом помечен целый метод, этот метод автоматически будет синхронизированным для всех объектов класса.
// .
// [насчет нескольких синхронизированных методов]
// .
// Каждый из методов выполняется на правах взаимоисключающего владения объектом – как только стартует один из методов,
// все другие вызовы любых методов объекта откладываются и могут быть реализованы только после того,
// как первый завершит работу.
// Поле intTrans защищено от асинхронных изменений,
// поскольку доступ к нему ограничен методами, обозначенными признаком synchronized.
// Если значение поля изменяется, оно не может быть считано другим потоком до тех пор,
// пока первый не завершит операцию сохранения.
// .
// .
// .
// [Volatile]
// Определение переменной с ключевым словом volatile означает,
// что значение этой переменной может изменяться другими потоками. Чтобы понять, что делает volatile,
// полезно разобраться, как потоки обрабатывают обычные переменные.
// В целях повышения производительности спецификация языка Java допускает сохранение в JRE локальной копии
// переменной для каждого потока, который на нее ссылается. Такие "локальные" копии переменных напоминают кэш
// и помогают потоку избежать обращения к главной памяти каждый раз, когда требуется получить значение переменной.
// При запуске двух потоков один из них считывает переменную A как 5, а второй ― как 10.
// Если значение переменной А изменилось с 5 на 10, то первый поток не узнает об изменении
// и будет хранить неправильное значение A. Но если переменная А помечена как volatile,
// то когда бы поток не считывал значение A, он будет обращаться к главной копии A и считывать ее текущее значение.
// Локальный кэш потока имеет смысл в том случае, если переменные в ваших приложениях не будут изменяться извне.
// Если переменная объявлена как volatile, это означает, что она может изменяться разными потоками.
// Естественно ожидать, что JRE обеспечит ту или иную форму синхронизации таких volatile-переменных.
// JRE действительно неявно обеспечивает синхронизацию при доступе к volatile-переменным,
// но с одной очень большой оговоркой: чтение volatile-переменной и запись в volatile-переменную синхронизированы,
// а неатомарные операции ― нет.